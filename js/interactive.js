// Generated by CoffeeScript 1.6.3
(function() {
  var addOutputNode, animSpeed, coffee, compile, consoleBox, exp, explanations, fs, lang, msgColors, outputBox, printBlock, printResult, printUnescaped, _fn;

  if (typeof require !== "undefined" && require !== null) {
    coffee = require("coffee-script");
    fs = require("fs");
  }

  outputBox = $("#output");

  consoleBox = $("#console");

  animSpeed = 80;

  lang = "javascript";

  compile = {
    javascript: function(source) {
      return source;
    }
  };

  if (coffee != null) {
    compile.coffeescript = function(source) {
      return coffee.compile(source, {
        bare: true
      });
    };
    lang = "coffeescript";
  }

  window.pg = {
    setLang: function(newLang) {
      newLang = newLang.toLowerCase();
      if (newLang in compile) {
        lang = newLang;
        return "now using " + lang;
      } else {
        throw new Error("" + newLang + " is not a supported language");
      }
    },
    say: function(message) {
      printResult(message, "user");
    },
    show: function(filename) {
      fs.readFile(filename, 'utf8', function(err, content) {
        var _ref;
        if (err) {
          throw err;
        }
        if ((_ref = filename.toLowerCase().split(".").pop()) === "md" || _ref === "markdown" || _ref === "mdown") {
          content = require("marked")(content);
        }
        return printUnescaped(content, "user");
      });
    },
    ls: function() {
      return fs.readdirSync(".").join("\n");
    },
    cwd: process.cwd,
    cd: function(path) {
      process.chdir(path);
      return process.cwd();
    },
    exec: function(command) {
      var child;
      child = require("child_process").exec(command);
      child.stdout.on("data", function(output) {
        return printResult(output.toString());
      });
      child.stderr.on("data", function(output) {
        return printResult(output.toString(), 'error');
      });
    },
    "import": function(funcName) {
      if (!(funcName in pg)) {
        throw "" + funcName + " is not a valid playground function";
      }
      window[funcName] = pg[funcName];
      return "imported " + funcName + " to global namespace";
    }
  };

  explanations = {
    ls: "list all files and directories in the current working directory",
    cwd: "print the current directory",
    cd: "change the current working directory",
    exec: "execute a system command",
    show: "display the contents of a file (renders html/markdown)",
    egsg: "error"
  };

  _fn = function(exp) {
    var _ref;
    return (_ref = pg[exp]) != null ? _ref.toString = function() {
      return explanations[exp];
    } : void 0;
  };
  for (exp in explanations) {
    _fn(exp);
  }

  addOutputNode = function(node) {
    var doc;
    node.appendTo(outputBox).hide().fadeIn(animSpeed);
    return (doc = $(document)).scrollTop(doc.height());
  };

  printBlock = function(code) {
    var innerBox;
    innerBox = $("<code></code>").addClass("language-" + lang).text(code);
    addOutputNode($("<pre class='out-block'></pre>").append(innerBox));
    return Prism.highlightElement(innerBox[0]);
  };

  msgColors = {
    user: "navy",
    error: "maroon",
    success: "darkgreen",
    "default": "darkgreen"
  };

  printResult = function(result, msgType) {
    var color, e, resStr;
    color = msgColors[msgType] || msgColors["default"];
    resStr = result != null ? result.toString() : void 0;
    if (resStr.match(/\[object/)) {
      try {
        resStr = JSON.stringify(result);
      } catch (_error) {
        e = _error;
        resStr;
      }
    }
    return addOutputNode($("<pre class='result-block'></pre>").text(resStr).css({
      color: color
    }));
  };

  printUnescaped = function(output, msgType) {
    return addOutputNode($("<pre class='result-block unescaped'></pre>").html(output));
  };

  consoleBox.on("keydown", function(e) {
    var err, res, source;
    source = consoleBox.val().trim();
    if (e.keyCode === 13 && !e.shiftKey && source !== "") {
      e.preventDefault();
      consoleBox.val("");
      printBlock(source);
      try {
        source = compile[lang](source);
        res = eval.call(window, source);
        if (res !== void 0) {
          return printResult(res);
        }
      } catch (_error) {
        err = _error;
        return printResult(err, "error");
      }
    }
  });

  outputBox.on("click", ".out-block", function(e) {
    return consoleBox.focus().val($(this).text());
  });

  if (typeof process !== "undefined" && process !== null) {
    process.on("uncaughtException", function(err) {
      return printResult(err, "error");
    });
  }

}).call(this);
